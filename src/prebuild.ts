import * as ts from "typescript";

import * as fsp from "fs/promises";

import * as path from "path";
import { IPrebuildMetadata } from "./container";

import chokidar from "chokidar";
import pc from "picocolors";

interface IPrebuildConfig {
  projectFolder: string;
  packageImportPath: string;
  isWatchMode: boolean;
  outputPath: string;
}

let cfg: IPrebuildConfig = {
  projectFolder: process.cwd(),
  packageImportPath: "genioc",
  isWatchMode: false,
  outputPath: "genioc.autogenerated.ts",
};

async function compileAndCollectMetadata(): Promise<IPrebuildMetadata> {
  const configPath = ts.findConfigFile(
    cfg.projectFolder,
    ts.sys.fileExists,
    "tsconfig.json"
  );
  if (!configPath) {
    console.error(`Error: tsconfig.json not found`);
    process.exit(1);
  }

  const prebuildMetadata: IPrebuildMetadata = {
    constructors: {},
    injectableTypes: new Set(),
  };

  const { config } = ts.readConfigFile(configPath, ts.sys.readFile);

  const { options, fileNames, errors } = ts.parseJsonConfigFileContent(
    config,
    ts.sys,
    cfg.projectFolder
  );

  const program = ts.createProgram({
    options,
    rootNames: fileNames,
    configFileParsingDiagnostics: errors,
  });

  const checker = program.getTypeChecker();

  for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile.isDeclarationFile) continue;

    if (sourceFile.fileName.includes(cfg.outputPath)) continue;

    ts.forEachChild(sourceFile, (node) => {
      if (!ts.isClassDeclaration(node)) return;
      if (!node.name) return;

      const constructorDependencies = [];

      let symbol = checker.getSymbolAtLocation(node.name)!;

      const className = symbol.getName();

      let constructorType = checker.getTypeOfSymbolAtLocation(
        symbol,
        symbol.valueDeclaration!
      );

      const signatures = constructorType.getConstructSignatures();

      const firstSignature = signatures[0]!;

      for (const param of firstSignature.parameters) {
        const paramType = checker.getTypeOfSymbolAtLocation(
          param,
          param.valueDeclaration!
        );

        if (!paramType.isClassOrInterface()) continue;

        const injectableDependencyName = checker.typeToString(paramType);

        constructorDependencies.push(injectableDependencyName);
        prebuildMetadata.injectableTypes.add(injectableDependencyName);
      }

      prebuildMetadata.constructors[className] = constructorDependencies;
    });
  }

  return prebuildMetadata;
}

async function writeAutogeneratedCode(metadata: IPrebuildMetadata) {
  const outputPath = path.join(cfg.projectFolder, cfg.outputPath);

  const constructorsMetadataValue = JSON.stringify(
    metadata.constructors,
    null,
    2
  );
  const unionTokensTypeValue = Array.from(metadata.injectableTypes)
    .map((name) => `"${name}"`)
    .join(" | ");

  const packageImportPathValue = cfg.packageImportPath;

  const templateCodeBuffer = await fsp.readFile(
    path.join(__dirname, "autogenerated.tstemplate")
  );

  const templateCode = templateCodeBuffer.toString("utf-8");

  const compiledTemplate = templateCode
    .replace("%constructorsMetadata%", constructorsMetadataValue)
    .replace("%unionTokensType%", unionTokensTypeValue)
    .replace("%packageImportPath%", packageImportPathValue);

  await fsp.writeFile(outputPath, compiledTemplate);
}

function parseCommandLine() {
  const cliArguments = process.argv.slice(2);

  for (let i = 0; i < cliArguments.length; i++) {
    const argument = cliArguments[i];

    if (argument === "--dev") {
      cfg.packageImportPath = "../src";
      continue;
    }

    if (argument === "--watch" || argument === "-w") {
      cfg.isWatchMode = true;
      continue;
    }

    if (argument === '--output' || argument === '-o') {
      if (i+1 >= cliArguments.length) continue;

      cfg.outputPath = cliArguments[i+1];
      i++;
      continue;
    }

    if (argument === "--help" || argument === "-h") {
      console.log(`Usage: genioc [--watch | -w] [--output | -o <output path> ] [project folder]`);
      process.exit(0);
    }

    const isPassedPathAbsolute = path.isAbsolute(argument);

    cfg.projectFolder = isPassedPathAbsolute
      ? argument
      : path.join(process.cwd(), argument);
  }
}

async function buildAndEmit() {
  const timeStart = Date.now();

  console.log(`Compiling project ${cfg.projectFolder}`);
  const metadata = await compileAndCollectMetadata();

  console.log(`Writing autogenerated code...`);
  await writeAutogeneratedCode(metadata);

  const timeSpent = Date.now() - timeStart;

  console.log(`Done in ${timeSpent} ms.`);
}

function runWatchMode() {
  let isAlreadyBuilding = false

  const runWatchTrigger = async () => {
    isAlreadyBuilding = true;
    await buildAndEmit();
    isAlreadyBuilding = false;
  };

  chokidar
    .watch(cfg.projectFolder, {
      ignoreInitial: true,
    })
    .on("change", async (changedPath) => {
      if (isAlreadyBuilding) return;
      if (!changedPath.includes('.ts')) return;
      if (changedPath.includes(cfg.outputPath)) return;

      console.log(
        pc.yellow(
          `[W] Detected change in project source code, rebuilding IoC container...`
        )
      );
      runWatchTrigger();
    });
}

async function run() {
  parseCommandLine();

  if (cfg.isWatchMode) {
    console.log(pc.bold(`Now watching directory "${cfg.projectFolder}"`));

    runWatchMode();
  } else {
    await buildAndEmit();
  }
}

run();

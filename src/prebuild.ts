import * as ts from "typescript";

import * as fsp from "fs/promises";

import * as path from "path";
import { IPrebuildMetadata } from "./container";

const projectFolder =
  process.argv.slice(2).find((arg) => !arg.startsWith("--")) || process.cwd();

const autogeneratedFilename = "genioc.autogenerated.ts";

async function compileAndCollectMetadata(): Promise<IPrebuildMetadata> {
  const configPath = ts.findConfigFile(
    projectFolder,
    ts.sys.fileExists,
    "tsconfig.json"
  );
  if (!configPath) {
    console.error(`Error: tsconfig.json not found`);
    process.exit(1);
  }

  console.log(`Building dependency metadata with tsconfig at ${configPath}`);

  const prebuildMetadata: IPrebuildMetadata = {
    constructors: {},
    injectableTypes: new Set(),
  };

  const { config } = ts.readConfigFile(configPath, ts.sys.readFile);

  const { options, fileNames, errors } = ts.parseJsonConfigFileContent(
    config,
    ts.sys,
    projectFolder
  );

  const program = ts.createProgram({
    options,
    rootNames: fileNames,
    configFileParsingDiagnostics: errors,
  });

  const checker = program.getTypeChecker();

  for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile.isDeclarationFile) continue;
    
    if (sourceFile.fileName.includes(autogeneratedFilename)) continue;

    ts.forEachChild(sourceFile, (node) => {
      if (!ts.isClassDeclaration(node)) return;
      if (!node.name) return;

      const constructorDependencies = [];

      let symbol = checker.getSymbolAtLocation(node.name)!;

      const className = symbol.getName();

      let constructorType = checker.getTypeOfSymbolAtLocation(
        symbol,
        symbol.valueDeclaration!
      );

      const signatures = constructorType.getConstructSignatures();

      const firstSignature = signatures[0]!;

      for (const param of firstSignature.parameters) {
        const paramType = checker.getTypeOfSymbolAtLocation(
          param,
          param.valueDeclaration!
        );

        if (!paramType.isClassOrInterface()) continue;

        const injectableDependencyName = checker.typeToString(paramType);

        constructorDependencies.push(injectableDependencyName);
        prebuildMetadata.injectableTypes.add(injectableDependencyName);
      }

      prebuildMetadata.constructors[className] = constructorDependencies;
    });
  }

  return prebuildMetadata;
}

async function writeAutogeneratedCode(metadata: IPrebuildMetadata) {
  console.log(`Writing autogenerated code...`);

  const outputPath = path.join(projectFolder, autogeneratedFilename);

  const constructorsMetadataValue = JSON.stringify(
    metadata.constructors,
    null,
    2
  );
  const unionTokensTypeValue = Array.from(metadata.injectableTypes)
    .map((name) => `"${name}"`)
    .join(" | ");

  const packageImportPathValue = process.argv.includes("--dev")
    ? "../src"
    : "genioc";

  const templateCodeBuffer = await fsp.readFile(
    path.join(__dirname, "autogenerated.tstemplate")
  );

  const templateCode = templateCodeBuffer.toString("utf-8");

  const compiledTemplate = templateCode
    .replace("%constructorsMetadata%", constructorsMetadataValue)
    .replace("%unionTokensType%", unionTokensTypeValue)
    .replace("%packageImportPath%", packageImportPathValue);

  await fsp.writeFile(outputPath, compiledTemplate);
}

async function run() {
  const timeStart = Date.now();

  const metadata = await compileAndCollectMetadata();

  await writeAutogeneratedCode(metadata);

  const timeSpent = Date.now() - timeStart;

  console.log(`Done in ${timeSpent} ms.`);
}

run();

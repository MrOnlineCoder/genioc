import * as ts from "typescript";

import * as fsp from "fs/promises";

import * as path from "path";
import { IPrebuildMetadata } from "./container";

interface IPrebuildConfig {
  projectFolder: string;
  packageImportPath: string;
}

let cfg: IPrebuildConfig = {
  projectFolder: process.cwd(),
  packageImportPath: 'genioc'
}

const autogeneratedFilename = "genioc.autogenerated.ts";

async function compileAndCollectMetadata(): Promise<IPrebuildMetadata> {
  const configPath = ts.findConfigFile(
    cfg.projectFolder,
    ts.sys.fileExists,
    "tsconfig.json"
  );
  if (!configPath) {
    console.error(`Error: tsconfig.json not found`);
    process.exit(1);
  }

  const prebuildMetadata: IPrebuildMetadata = {
    constructors: {},
    injectableTypes: new Set(),
  };

  const { config } = ts.readConfigFile(configPath, ts.sys.readFile);

  const { options, fileNames, errors } = ts.parseJsonConfigFileContent(
    config,
    ts.sys,
    cfg.projectFolder
  );

  const program = ts.createProgram({
    options,
    rootNames: fileNames,
    configFileParsingDiagnostics: errors,
  });

  const checker = program.getTypeChecker();

  for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile.isDeclarationFile) continue;
    
    if (sourceFile.fileName.includes(autogeneratedFilename)) continue;

    ts.forEachChild(sourceFile, (node) => {
      if (!ts.isClassDeclaration(node)) return;
      if (!node.name) return;

      const constructorDependencies = [];

      let symbol = checker.getSymbolAtLocation(node.name)!;

      const className = symbol.getName();

      let constructorType = checker.getTypeOfSymbolAtLocation(
        symbol,
        symbol.valueDeclaration!
      );

      const signatures = constructorType.getConstructSignatures();

      const firstSignature = signatures[0]!;

      for (const param of firstSignature.parameters) {
        const paramType = checker.getTypeOfSymbolAtLocation(
          param,
          param.valueDeclaration!
        );

        if (!paramType.isClassOrInterface()) continue;

        const injectableDependencyName = checker.typeToString(paramType);

        constructorDependencies.push(injectableDependencyName);
        prebuildMetadata.injectableTypes.add(injectableDependencyName);
      }

      prebuildMetadata.constructors[className] = constructorDependencies;
    });
  }

  return prebuildMetadata;
}

async function writeAutogeneratedCode(metadata: IPrebuildMetadata) {
  const outputPath = path.join(cfg.projectFolder, autogeneratedFilename);

  const constructorsMetadataValue = JSON.stringify(
    metadata.constructors,
    null,
    2
  );
  const unionTokensTypeValue = Array.from(metadata.injectableTypes)
    .map((name) => `"${name}"`)
    .join(" | ");

  const packageImportPathValue = cfg.packageImportPath;

  const templateCodeBuffer = await fsp.readFile(
    path.join(__dirname, "autogenerated.tstemplate")
  );

  const templateCode = templateCodeBuffer.toString("utf-8");

  const compiledTemplate = templateCode
    .replace("%constructorsMetadata%", constructorsMetadataValue)
    .replace("%unionTokensType%", unionTokensTypeValue)
    .replace("%packageImportPath%", packageImportPathValue);

  await fsp.writeFile(outputPath, compiledTemplate);
}

function parseCommandLine() {
  for (const argument of process.argv.slice(2)) {
    if (argument === '--dev') {
      cfg.packageImportPath = '../src';
      continue;
    }

    if (argument === '--help' || argument === '-h') {
      console.log(`Usage: genioc [--watch | -w] [project folder]`);
      process.exit(0);
    }

    cfg.projectFolder = argument;
  }
}

async function runPrebuildScript() {
  const timeStart = Date.now();

  parseCommandLine();

  console.log(`Building dependency metadata for project: ${cfg.projectFolder}`);
  const metadata = await compileAndCollectMetadata();

  console.log(`Writing autogenerated code...`);
  await writeAutogeneratedCode(metadata);

  const timeSpent = Date.now() - timeStart;

  console.log(`Done in ${timeSpent} ms.`);
}

runPrebuildScript();